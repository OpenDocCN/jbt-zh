# 链表

> 原文： [https://javabeginnerstutorial.com/data-structure/linked-list/](https://javabeginnerstutorial.com/data-structure/linked-list/)

## 什么是链表？

链表是另一种数据结构，也是一种常见的数据结构，它包括按顺序分为两组的一组节点，每个节点由数据和下一个节点的地址部分组成，并形成一个链。 它用于创建树和图。

![](data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%200%200'%3E%3C/svg%3E)

<noscript><img alt="" class="aligncenter" src="img/dad80980cebe0f36f4f53d0512b7bde7.png"/><p><strong>优点<br/> </strong></p><li><div style="background: white;">本质上是动态的，并在需要时分配内存。 </div></li><li><div style="background: white;">有两个可以在链接列表中轻松实现的操作，即插入和删除。 </div></li><li><div style="background: white;">减少访问时间。 </div></li><p><strong>缺点<br/> </strong></p><li><div style="text-align: justify;">内存浪费了，因为指针需要额外的存储空间。 </div></li><li><div style="text-align: justify;">该元素不能随机访问，可以顺序访问。 </div></li><li><div style="text-align: justify;">在链表中，反向遍历很困难。 </div></li><p> </p><h2>在哪里使用链表？</h2><p> </p><p>1.它们用于实现栈，队列，图形等。</p><p>2.它们使您可以在列表的开头和结尾插入元素。</p><p>3.在此不需要事先知道大小。</p><h2>链接列表的类型</h2><h3 style="text-align: justify;">单链表-</h3><div style="text-align: justify;">This type of list contains nodes which have a data part as well as an address part, i.e. next, and it points to the next node in the given sequence of nodes. The operations we can perform on singly linked lists are inserted, deletion and traversal</div><div style="text-align: justify;">.<img alt="" class="aligncenter" src="img/4a148b6da2746309be0686186d6750a5.png"/></div><p> </p><h3 style="text-align: justify;">双链表-</h3><div style="text-align: justify;">In this type of list, each node contains the two links, the first link will point to the previous node and the next link will point to the next node in the sequence.</div><p><img alt="" class="aligncenter" data-lazy-src="https://javabeginnerstutorial.com/wp-content/uploads/2016/08/083116_1919_3-1.png" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%200%200'%3E%3C/svg%3E"/></p><noscript><img alt="" class="aligncenter" src="img/59ce98a963af9fd19a1e555e355e1545.png"/><span class="ezoic-adpicker-ad" id="ezoic-pub-ad-placeholder-124"></span><span class="ezoic-ad box-4 adtester-container adtester-container-124" data-ez-name="javabeginnerstutorial_com-box-4" style="display:block !important;float:none;margin-bottom:2px !important;margin-left:0px !important;margin-right:0px !important;margin-top:2px !important;min-height:110px;min-width:728px;text-align:center !important;"><span class="ezoic-ad ezoic-adl" ezah="90" ezaw="728" id="div-gpt-ad-javabeginnerstutorial_com-box-4-0" style="position:relative;z-index:0;display:inline-block;min-height:90px;min-width:728px;"></span></span><li><div style="text-align: justify;">Circular Linked List- In this type of list, the last node of the list contains the address of the first node and will form a circular chain.</div><p><img alt="" data-lazy-src="https://javabeginnerstutorial.com/wp-content/uploads/2016/08/083116_1919_4-1.gif" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%200%200'%3E%3C/svg%3E"/></p><noscript><img alt="" src="img/af364b81f54d889be6e5f4ef293d45f7.png"/></li><h2>单链表</h2><p style="text-align: justify;">单链接列表是其中每个节点仅包含一个指向下一个节点的链接字段的列表。 在这种情况下，节点分为两部分，第一部分是数据部分，另一部分是包含下一个节点地址的链接部分。 第一个节点是标头节点，其中包含下一个节点的数据和地址，依此类推。 单链列表也称为单向列表，因为它只能从左到右遍历，而另一种方式则是不可能的。</p><p><strong> <br/> <img alt="" class="aligncenter" src="img/d817dfb8abf09275b68106fa03e8c326.png"/> <br/> </strong></p><h3><strong> <br/> </strong>在哪里使用单链表？</h3><p>单链列表可以在使用后进先出概念的栈中使用。 此列表维护与列表中头节点的链接，每个节点都指向列表中的下一个节点。 它也可以用于先入先出的队列中。 <strong> <br/> </strong></p><p><strong>在 C <br/> </strong>中实现单链表</p><pre><code class="language-c">#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct Node { int data; struct Node *next; }node; void insert(node *ptr, int data) { while(ptr-&gt;next!=NULL) { ptr = ptr -&gt; next; } ptr-&gt;next = (node *)malloc(sizeof(node)); ptr = ptr-&gt;next; ptr-&gt;data = data; ptr-&gt;next = NULL; } int find(node *ptr, int key) { ptr = ptr -&gt; next; while(ptr!=NULL) { if(ptr-&gt;data == key) { return 1; } ptr = ptr -&gt; next; } return 0; } void delete(node *ptr, int data) { while(ptr-&gt;next!=NULL &amp;&amp; (ptr-&gt;next)-&gt;data != data) { ptr = ptr -&gt; next; } if(ptr-&gt;next==NULL) { printf("Element %d is not present in the list\n",data); return; } node *temp; temp = ptr -&gt; next; ptr-&gt;next = temp-&gt;next; free(temp); return; } void print(node *ptr) { if(ptr==NULL) { return; } printf("%d ",ptr-&gt;data); print(ptr-&gt;next); } int main() { node *start,*temp; start = (node *)malloc(sizeof(node)); temp = start; temp -&gt; next = NULL; printf("1\. Insert\n"); printf("2\. Delete\n"); printf("3\. Print\n"); printf("4\. Find\n"); while(1) { int option; scanf("%d",&amp;option); if(option==1) { int data; scanf("%d",&amp;data); insert(start,data); } else if(option==2) { int data; scanf("%d",&amp;data); delete(start,data); } else if(option==3) { printf("The list is "); print(start-&gt;next); printf("\n"); } else if(option==4) { int data; scanf("%d",&amp;data); int result = find(start,data); if(result) { printf("The element is found \n"); } else { printf("The element is not found\n"); } } } }</code></pre><p> </p><h2>双链表</h2><p style="text-align: justify;">双链列表也称为双向列表或双向链。 在双向链接列表中，两个链接字段被保留，而不是像在单个链接列表中那样保留一个链接字段。 双链表是一个线性数据结构，其中每个节点都有两个链接，其中第一个链接用于指向前一个节点，下一个链接指向下一个节点。 在双向链表上执行的操作是插入，删除，搜索和遍历。</p><p><img alt="" class="aligncenter" data-lazy-src="https://javabeginnerstutorial.com/wp-content/uploads/2016/08/083116_1919_6-1.png" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%200%200'%3E%3C/svg%3E"/></p><noscript><img alt="" class="aligncenter" src="img/7a389efd6dc538c5ebbb7205956dc446.png"/><strong><br/> </strong><h3>在哪里使用双向链表？ <strong> <br/> </strong></h3><ol style="margin-left: 78pt;"><li><div style="text-align: justify;">用于表示游戏中的纸牌。 </div></li><li><div style="text-align: justify;">在具有“最近使用”列表的应用中使用。 </div></li><li><div style="text-align: justify;">在 Word 或 Photoshop 中用作撤消功能。 </div></li><li><div style="text-align: justify;">在浏览器缓存中使用，它使我们可以单击 BACK 按钮。 </div></li></ol><p><strong>使用 C <br/> </strong>实现双向链表</p><pre><code class="language-c">#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct Node { int data; struct Node *next; struct Node *prev; }node; void insert(node *ptr, int data) { while(ptr-&gt;next!=NULL) { ptr = ptr -&gt; next; } ptr-&gt;next = (node *)malloc(sizeof(node)); (ptr-&gt;next)-&gt;prev = ptr; ptr = ptr-&gt;next; ptr-&gt;data = data; ptr-&gt;next = NULL; } int find(node *ptr, int key) { ptr = ptr -&gt; next; while (ptr!=NULL) { if(ptr-&gt;data == key) { return 1; } ptr = ptr -&gt; next; } return 0; } void delete(node *ptr, int data) { while(ptr-&gt;next!=NULL &amp;&amp; (ptr-&gt;next)-&gt;data != data) { ptr = ptr -&gt; next; } if(ptr-&gt;next==NULL) { printf("The element %d is not present in the list\n",data); return; } node *temp; temp = ptr -&gt; next; ptr-&gt;next = temp-&gt;next; temp-&gt;prev = ptr; free(temp); return; } void print(node *ptr) { if(ptr==NULL) { return; } printf("%d ",ptr-&gt;data); print(ptr-&gt;next); } int main() { node *start,*temp; start = (node *)malloc(sizeof(node)); temp = start; temp -&gt; next = NULL; temp -&gt; prev = NULL; printf("1\. Insert\n"); printf("2\. Delete\n"); printf("3\. Print\n"); printf("4\. Find\n"); while(1) { int option; scanf("%d",&amp;option); if(option==1) { int data; scanf("%d",&amp;data); insert(start,data); } else if(option==2) { int data; scanf("%d",&amp;data); delete(start,data); } else if(option==3) { printf("The list is "); print(start-&gt;next); printf("\n"); } else if(option==4) { int data; scanf("%d",&amp;data); int result = find(start,data); if(result) { printf("The element is found\n"); } else { printf("The element is not found\n"); } } } }</code></pre><h2>循环链接列表<strong> <br/> </strong></h2><p style="text-align: justify;">循环链接列表是有点复杂的链接数据结构。 在此列表中，我们可以在列表中的任何位置插入元素，而在数组中，我们不能在列表中的任何位置插入元素，因为它在连续内存中。 在此列表中，上一个元素存储下一个元素的地址，最后一个元素存储第一个元素的地址。 列表中的元素以圆形的方式相互指向，形成圆形的链。 该列表具有动态大小，这意味着可以在需要时分配内存。</p><p><img alt="" class="aligncenter" data-lazy-src="https://javabeginnerstutorial.com/wp-content/uploads/2016/08/083116_1919_7-1.gif" src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%200%200'%3E%3C/svg%3E"/></p><noscript><img alt="" class="aligncenter" src="img/7c690997d7c97fed9dbff4cd835a897a.png"/><h3>在哪里使用循环链表？ <strong> <br/> </strong></h3><p style="text-align: justify;">使用此列表的实际应用是在其上运行多个应用的​​PC。 循环链接列表在操作系统中很常见，因为它会将正在运行的应用放在列表中，并且当列表即将到达其末端时，操作系统很容易使用循环链接列表，因为操作系统可以循环运行 在列表的最前面。 将该时隙分配给列表中的每个应用。</p><p><strong>在 C <br/> </strong>中实现循环链​​表</p><pre><code class="language-c">#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; struct node { int data; struct node *next; }node; void insert(node *pointer, int data) { node *start = pointer; while(pointer-&gt;next!=start) { pointer = pointer -&gt; next; } pointer-&gt;next = (node *)malloc(sizeof(node)); pointer = pointer-&gt;next; pointer-&gt;data = data; pointer-&gt;next = start; } void delete(node *pointer, int data) { node *start = pointer; while(pointer-&gt;next!=start &amp;&amp; (pointer-&gt;next)-&gt;data != data) { pointer = pointer -&gt; next; } if(pointer-&gt;next==start) { printf("Element %d is not present in the list\n",data); return; } node *temp; temp = pointer -&gt; next; pointer-&gt;next = temp-&gt;next; free(temp); free( ) return; } void display(node *start,node *pointer) { if(pointer = = start) { return; } printf("%d ",pointer-&gt;data); display(start,pointer-&gt;next); } void main() { node *start,*temp; start = (struct node *)malloc(sizeof(struct node)); temp = start; temp -&gt; next = start; printf("1\. Insert\n"); printf("2\. Delete\n"); printf("3\. Display\n"); while(1) { int query; scanf("%d",&amp;query); if(query==1) { int data; scanf("%d",&amp;data); insert(start,data); } else if(query==2) { int data; scanf("%d",&amp;data); delete(start,data); } else if(query==3) { printf("The list is "); display(start,start-&gt;next); printf("\n"); } } getch( ); }</code></pre><h2>线性链接列表<strong> <br/> </strong></h2><p style="margin-left: 35pt;">在链表中，我们可以通过三种方式插入元素：</p><li><div style="text-align: justify;">插入列表的开头。 </div></li><li><div style="text-align: justify;">插入列表的中间。 </div></li><li><div style="text-align: justify;">插入到列表的末尾。 </div></li><p>在将节点插入列表之前，我们将使用关键字 struct 创建一个结构。 例如：</p><pre><code class="language-c">struct node { int data; struct node *next; }; struct employee *start=NULL, *temp,*q;</code></pre><p>并且在定义了结构之后，在从列表中插入或删除节点的同时，给出了特定的功能定义或功能原型。 例如：</p><pre><code class="language-c">void insertbeg( ); void insertmiddle( ); void insertlast( ); void deletebeg( );</code></pre><p>上面给出的函数定义在 main 函数之前定义，即 void main（）或 int main（）。</p><p><strong>在开头的插入元素<br/> </strong></p><p>在开始时插入节点的步骤：</p><ol style="margin-left: 87pt;"><li><div style="text-align: justify;">创建一个新节点。 </div></li><li><div style="text-align: justify;">在数据部分输入数据。 </div></li><li><div style="text-align: justify;">将地址部分或下一部分设为 NULL。 </div></li><li><div style="text-align: justify;">现在将这个新创建的节点附加到 START 或 HEAD。 </div></li><li><div style="text-align: justify;">现在，将此起始节点设为起始节点或标头节点。 </div></li></ol><p>实作</p><p><strong>在中间的插入元素<br/> </strong></p><p style="text-align: justify; margin-left: 42pt;">在中间插入节点的步骤：</p><ol style="margin-left: 78pt;"><li><div style="text-align: justify;">将要添加的 NEW 节点的数据写入列表及其位置。 </div></li><li><div style="text-align: justify;">通过调用 malloc（）创建一个新的空节点。 </div></li><li><div style="text-align: justify;">将数据插入 NEW 节点的数据部分。 </div></li><li><div style="text-align: justify;">将此 NEW 节点添加到列表中的所需位置。 </div></li><li><div style="text-align: justify;">转到步骤 1，直到您在列表中添加了所有值。 </div></li></ol><p style="text-align: justify;"><strong>实现<br/> </strong></p><pre><code class="language-c">void insertmiddle() { int pos,i,num; if(start==NULL) { printf("\nList is empty!! Sorry..."); } temp=(struct node*)malloc(sizeof(struct node)); printf("\nEnter the details:"); scanf("%d",num); printf("\nEnter position:"); scanf("%d",&amp;pos); temp-&gt;data=num; q=start for(i=1;i&lt;pos-1;pos++) { if(q-&gt;next==NULL) { printf("\nLess elements in the list"); } q=q-&gt;next; } temp-&gt;next=q-&gt;next; q-&gt;next=temp; getch(); }</code></pre><p><strong>插入元素位于列表的最后：<br/> </strong></p><p><strong> <br/> </strong>最后插入节点的步骤：</p><ol style="margin-left: 70pt;"><li>创建新节点。</li><li>将数据输入到节点的数据部分。</li><li>将节点的下一部分设为 NULL。</li><li>要在最后一个位置插入节点，因此我们必须遍历到最后一个节点。</li><li>在最后一个节点和新节点之间建立链接。</li></ol><p><strong>实现<br/> </strong></p><pre><code class="language-c">void insertlast() { int num; temp=(struct node*)malloc(sizeof(struct node)); printf("\nEnter the details:"); scanf("%d",&amp;num); temp-&gt;data=num; temp-&gt;next=NULL; if(start==NULL) //If list is empty { start=temp; } else { q=start; while(q-&gt;next!=NULL) q=q-&gt;next; q-&gt;next=temp; } }</code></pre><p><strong>删除</strong></p><p>可以通过三种方式删除该元素：</p><li><div style="text-align: justify;">从列表的开头删除。 </div></li><li><div style="text-align: justify;">从列表的中间删除。 </div></li><li><div style="text-align: justify;">从列表末尾删除。 </div></li><p><strong>从开头删除元素<br/> </strong></p><pre><code class="language-c">Implementation void deletebeg() { if(start==NULL) { printf("\nThe list is empty..."); } else { q=start; start=start-&gt;next; free(q); printf("\nElement deleted..."); } }</code></pre><p><strong>从中间删除元素<br/> </strong></p><p>Implementation</p><pre><code class="language-c">void deletemiddle() { int pos,i; if(start==NULL) { printf("\nThe list is empty..."); } printf("\nEnter position to delete:"); scanf("%d",&amp;pos); for(i=1;i&lt;pos-1;pos++) { if(q-&gt;next==NULL) { printf("\nLess elements..."); getch(); } q=q-&gt;next; } temp=q-&gt;next; q-&gt;next=temp-&gt;next; free(temp); printf("\nElement deleted..."); getch(); }</code></pre><p><strong>从最后一个<br/> </strong>中删除元素</p><p>Implementation</p><pre><code class="language-c">void deletelast() { if(start==NULL) { printf("\nThe list is empty..."); } else { q=start; while(q-&gt;next-&gt;next!=NULL) q=q-&gt;next; temp=q-&gt;next; q-&gt;next=NULL; free(temp); printf("\nElement deleted..."); } }</code></pre><p style="text-align: justify; margin-left: 42pt;"><strong>显示<br/> </strong></p><p style="text-align: justify; margin-left: 42pt;">在执行任何操作后显示列表的元素。</p><pre><code class="language-c">void display() { struct node *q; q=start; while(q!=NULL) { printf("%d\t",q-&gt;data); q=q-&gt;next; } getch(); }</code></pre><p style="margin-left: 42pt;"></p> </body> </html></noscript>