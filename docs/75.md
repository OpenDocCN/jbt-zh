# Java 开发人员必须知道..

> 原文： [https://javabeginnerstutorial.com/core-java-tutorial/java-developers-must-know/](https://javabeginnerstutorial.com/core-java-tutorial/java-developers-must-know/)

## Java 虚拟机。 怎么运行的？

*   首先 jvm 在类中查找 main 方法。如果存在，它将从该处开始执行
*   在 Java 虚拟机内部，线程有两种形式： ***守护程序*** **和*非守护程序*** 。 守护程序线程通常是虚拟机本身使用的线程，例如执行**垃圾** **集合**的线程。 但是，该应用程序可以将其创建的任何线程标记为守护程序线程。 应用程序的初始线程（从 main（）开始的线程）是非守护程序线程。
*   只要任何非守护程序线程仍在运行，Java 应用程序就会继续执行（虚拟机实例继续运行）。 Java 应用程序的所有非守护程序线程都终止时，虚拟机实例将退出。 如果得到安全管理者的允许，则应用程序还可以通过调用 Runtime 或 System 类的 exit（）方法来使其自身灭亡。

**[** ![](data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20670%20299'%3E%3C/svg%3E)

<noscript><img alt="" height="299" src="img/84ced9a2cb730f97cce54806e6a7946b.png" width="670"/><p align="center"><strong> </strong></p><p align="center"><strong> Java 虚拟机的体系结构</strong></p><ul class="check"><li>所有的 JVM 都包含两个组成部分</li></ul><p style="padding-left: 60px;"><em> <span style="text-decoration: underline;">类加载器子系统</span> </em> <span style="text-decoration: underline;">：</span>一种机制，用于加载具有完全限定名称的类型（类和接口）。</p><p style="padding-left: 60px;"><em> <span style="text-decoration: underline;">执行引擎</span> </em>：一种机制，负责执行已加载类的方法中包含的指令。</p><ul class="check"><li style="text-align: justify;">当 Java 虚拟机运行程序时，它需要内存来存储许多东西，包括字节码，已加载的类文件中的信息，程序实例化的对象，方法的参数，返回值，局部变量以及中间的计算结果。</li></ul><ul class="check"><li style="text-align: justify;">虚拟机的不同实现可能具有非常不同的内存限制。 一些实现可能需要大量内存才能工作，而其他实现可能很少。 一些实现可能能够利用虚拟内存，而其他一些则不能。 运行时数据区规范的抽象性质有助于简化在各种计算机和设备上实现 Java 虚拟机的过程。</li><li style="text-align: justify;">不同的 Java 程序具有不同的 jvm 实例。 如果我执行一个类，则一个单独的 jvm 实例将处理该类</li><li style="text-align: justify;">当虚拟机加载类文件时，它会从类文件中包含的二进制数据中解析有关类型的信息。 它将类型信息放入方法区域，将程序实例化的所有对象放入堆。</li><li style="text-align: justify;">随着每个新线程的出现，它获得了自己的<em> pc 寄存器</em>（程序计数器）和<em> Java 堆栈</em>。 如果线程正在执行 Java 方法（不是本机方法），则 pc 寄存器的值指示要执行的下一条指令。 线程的 Java 堆栈存储该线程的 Java（非本机）方法调用状态。</li><li style="text-align: justify;">Java 堆栈由<em>堆栈帧</em>（或<em>帧</em>）组成。 堆栈框架包含一个 Java 方法调用的状态。 当线程调用方法时，Java 虚拟机将新框架推送到该线程的 Java 堆栈上。 该方法完成后，虚拟机将弹出并丢弃该方法的帧</li><li style="text-align: justify;">Java 虚拟机包含两种类加载器：java.lang.ClassLoader</li></ul><h3>b <em> ootstrap 类加载器，用户定义的类加载器</em>。</h3><ul class="check"><li style="text-align: justify;">正在运行的程序的每个线程都有其自己的<strong>程序计数器</strong>寄存器或程序计数器，它们是在线程启动时创建的。 pc 寄存器的大小为一个字，因此它既可以保存本机指针，也可以保存 returnAddress。 当线程执行 Java 方法时，pc 寄存器包含该线程正在执行的当前指令的地址。 “地址”可以是本机指针，也可以是方法字节码开头的偏移量。 如果线程正在执行本机方法，则 pc 寄存器的值未定义。</li><li>这里有两叠</li></ul><p><em> <strong> Java 堆栈：</strong> </em>由 JVM 维护，</p><p><em> <strong>本机堆栈：</strong> </em>取决于。</p><p>大家好，请评论我的帖子。 如果我的帖子有任何问题，请随时进行纠正，谢谢。</p><p> </p> </body> </html></noscript>