# 异常处理–尝试捕获Java块

> 原文： [https://javabeginnerstutorial.com/core-java-tutorial/exception-handling-try-catch-java/](https://javabeginnerstutorial.com/core-java-tutorial/exception-handling-try-catch-java/)

作为开发人员，我们每天处理风险情况。 服务器故障，或者没有足够的空间分配堆上的对象，或者给定位置不存在文件，依此类推。 因此，每次我们决定采取有风险的措施时，我们都必须通知编译器我们知道这是有风险的事情，并且已经准备好处理它。 我们如何处理这不是编译器的问题。 它需要记住的是，我们正在照顾可能出现的任何特殊情况。

我们通过将代码包装在Java的try catch中来处理这些情况。

### try / catch / finally块的基本语法：

```java
try{
     //code that could throw an exception
     //if exception thrown, following code is not reachable
     //control jumps to catch block
}catch(ExceptionType referenceVariable){
	//code that is executed only when an exception is thrown
	//does something using the exception reference variable
	//usually prints stack trace or exception description
}finally{
	//cleanup code
	//always executes regardless of an exception
}
```

### **注意**

1.  在try块和catch块之间不能编写任何代码。
2.  尝试块必须紧随其后的是catch或finally块，或二者兼而有之。 如果没有**捕获**块，则尽管finally方法具有try / finally，但final方法应**声明异常**。
3.  您将无法获得成功或最终没有尝试块。
4.  如果您不想在代码中处理异常，请使用**引发并声明**子句。 谁调用您的代码都必须使用try / catch块来处理它。

## **流量控制**

1.  如果 **try块成功**，即未引发异常，则控制将移至finally块（如果存在）。 跳过捕获块。 在没有finally块的情况下，将执行catch块下面的任何代码。
2.  如果 **try块失败**（发生异常），则控制权转移到处理异常的catch块。 try块中的其余代码永远不会执行。 如果存在finally块，则在catch块执行完成后运行。
3.  如果 **try / catch块**具有**返回语句**，那么即使执行finally块！ 流控制首先跳转到finally块，然后返回return语句。

### 例

```java
public class TryCatch1 {

public static void main(String[] args) {
	System.out.println(riskyAction());
	}

public static String riskyAction(){
	try{
		System.out.println("Started executing try block");
		return "returning from try block";
	}catch(Exception e){
		return "returning from catch blcok";
	}finally{
		System.out.println("print statement from finally");
	}
	}
}
```

### **输出**

```java
Started executing try block
print statement from finally
returning from try block
```

### **解释**

1.  try块运行并打印“开始执行try块”。
2.  一旦遇到return语句，流程将立即转移到finally块并打印“ finally的print语句”。
3.  最终块执行完成后，控制权返回try块中的return语句，并返回“从try块返回”。
4.  如果**最后的**块具有**返回语句**，则来自try / catch块的return语句将被覆盖。

### **范例**

```java
public class TryCatch2{

public static void main(String[] args) {
	System.out.println(riskyAction("hello"));
	System.out.println("-----------");
	System.out.println(riskyAction("howdy"));
	}

public static String riskyAction(String greeting){
	try{
		if(greeting.equals("hello")){
			System.out.println(greeting + " from try block");
		}else{
			throw new Exception();
		}
		return "returning from try block";
	}catch(Exception e){
		System.out.println(greeting + " from catch block");
		return "returning from catch block";
	}finally{
		return "returning from finally block";
	}
	}
}
```

### **Output**

```java
hello from try block
returning from finally block
-----------
howdy from catch block
returning from finally block
```

### **Explanation**

对于方法调用， *riskyAction* （“ hello”）：try块成功并打印“ try块中的hello”。 由于它具有return语句，因此控制权转移到finally块。 finally块还具有一个return语句，该语句将覆盖try块中的语句，因此该方法将返回“ finally块返回”并打印到控制台。

对于 *riskyAction* （“ howdy”）：try块引发异常，该异常在catch块中处理，该异常打印“ catch块中的howdy”。 就像我们在try块成功的情况下看到的一样，finally块的return语句也覆盖catch块中的return语句。 结果，该方法返回“从finally块返回”并打印到控制台。

**注意：**由于无论是否发生异常，finally块总是被执行，因此，如果它具有return语句，则可以预期到意外的结果，并且可能变得难以调试。 **作为一种好的做法，最好避免在finally块中编写return语句。**

## **捕获多个异常**

在Java 7之前，为了处理多个异常，使用了多个catch块（从最特定到最普通）。 编写代码是为了打印堆栈跟踪，执行错误恢复，链接异常，允许用户做出决定等。但是编写多个catch块包含许多**重复代码**。 另外，程序员倾向于捕获更广泛或更普遍的异常，而不是特定的异常。 例如，捕获IOException而不是FileNotFoundException。

从 **Java SE 7和更高版本**起，这些缺陷已通过**单捕获块**解决，该块可以**处理多种类型的异常**。 在这里，要处理的异常类型在以竖线（|）分隔的catch子句的主题中指定。

#### 例，

```java
catch(ArrayIndexOutOfBoundsException | SQLException ex){
	ex.printStackTrace();
}
```

#### **注意**

1.  每当单个catch块处理多个异常时，参考变量（上例中为“ ex”）为**最终**，因此将其视为常量。 因此，无法为其分配其他任何值。 在某些情况下，这限制了异常处理能力。
2.  不能将异常类型与其父类组合在一起，因为子类异常由于已经被捕获而变得不可访问。

#### **范例**

![multiple exceptions](img/79b92597e16d03f8894d2ed7abbede0e.png)

## **仔细查看Final模块**

1.  一旦try块中的控件退出，无论是否引发异常，都将始终执行finally块。
2.  最终块未执行，
    1.  如果在执行try / catch块代码时JVM退出
    2.  如果在控制权到达finally块之前执行了System.exit（）
    3.  如果执行try / catch代码的线程被中断或杀死
3.  最终块通过关闭可能已打开的资源来防止任何资源泄漏。
4.  如果要恢复任何资源，则必须将代码放在finally块中。
5.  仅带有finally块的try块（即没有catch块）仍应声明该异常以进行处理。

在 **Java SE 7和更高版本中，考虑使用try-with-resources语句**自动关闭不再使用的资源。 开发人员不需要为此记住通过编写finally块来释放使用的资源。

[try-with-resources语句帖子](https://javabeginnerstutorial.com/core-java-tutorial/exception-handling-try-resources/)提供了详细的信息以及其优势，摘要和示例代码片段。

###### 下一篇文章

##### [Java](https://javabeginnerstutorial.com/core-java-tutorial/overloading/ "Overloading in java") 中的重载